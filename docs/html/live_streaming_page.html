<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Valkka: Live streaming</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Valkka
   &#160;<span id="projectnumber">0.13.3</span>
   </div>
   <div id="projectbrief">OpenSource Video Management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Live streaming </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Some notes on receiving/sending live streams</p>
<h2>Receiving streams </h2>
<ul>
<li><a class="el" href="classLiveThread.html#a5155714795cf205ccb18b852076ebe60" title="A constant sized vector. Book-keeping of the connections (RTSP or SDP) currently active in the live55...">LiveThread::slots_</a> is a vector of <a class="el" href="classConnection.html" title="A base class that unifies all kinds of connections (RTSP and SDP). ">Connection</a> instances.</li>
<li>Let's assume there is an <a class="el" href="classRTSPConnection.html" title="A negotiated RTSP connection. ">RTSPConnection</a> instance in a slot. The <a class="el" href="classRTSPConnection.html#a9dab1076ce4f68c3f1ed49a59492bea5" title="ValkkaRTSPClient defines the behaviour (i.e. event registration and callbacks) of the RTSP client (se...">RTSPConnection::client</a> features a <a class="el" href="classValkkaRTSPClient.html" title="Handles a live555 RTSP connection. ">ValkkaRTSPClient</a> instance, that is derived from the live555 RTSPClient class. <a class="el" href="classValkkaRTSPClient.html" title="Handles a live555 RTSP connection. ">ValkkaRTSPClient</a> encapsulates all the usual live555 stuff, i.e. response handlers, callbacks, etc.</li>
<li><a class="el" href="classValkkaRTSPClient.html" title="Handles a live555 RTSP connection. ">ValkkaRTSPClient</a> has the target <a class="el" href="classFrameFilter.html" title="The mother class of all frame filters! FrameFilters are used to create &quot;filter chains&quot;. ">FrameFilter</a> where the frames are being fed. <a class="el" href="classValkkaRTSPClient.html#a94deddaff32c576d46195159a8503374" title="This points to a variable that is being used by LiveThread to inform about the stream state...">ValkkaRTSPClient::livestatus</a> is a reference to a shared variable that is used by <a class="el" href="classLiveThread.html#a8b53c829a1a8ec8a004d9e0df3e5e6c8" title="Used to (re)schedule LiveThread methods into the live555 event loop. ">LiveThread::periodicTask</a> to see if the client is alive or if it's been destroyed (calling the destructor happens within live555 callback chains) .. this part is a bit cumbersome, so fresh ideas are welcome.</li>
<li>Signaling with the "outside world" is done by a periodic live555 task <a class="el" href="classLiveThread.html#a8b53c829a1a8ec8a004d9e0df3e5e6c8" title="Used to (re)schedule LiveThread methods into the live555 event loop. ">LiveThread::periodicTask</a> that reads the signals sent from outside the thread (see <a class="el" href="classLiveThread.html#a369dac81c6bff35ab2d8ecfd014f084c" title="Handle pending signals in the signals queue. Used by LiveThread::periodicTask. ">LiveThread::handleSignals</a>)</li>
</ul>
<h2>Sending streams </h2>
<p>From the point of view of API users, sending frames happens simply by connecting a source to <a class="el" href="classLiveFifo.html" title="This is a special FrameFifo class for feeding frames into live555, i.e. ">LiveFifo</a> (see the examples). Behind the scene, frames are sent over the net, by calling <a class="el" href="classLiveFifo.html#af1040c40ceafed60fe2d60a5f24baa9b" title="Take a frame &quot;ftmp&quot; from the stack, copy contents of &quot;f&quot; into &quot;ftmp&quot; and insert &quot;ftmp&quot; into the begin...">LiveFifo::writeCopy</a> - i.e. using the unified approach in Valkka library to handle frames; they are handled in the same way, whether they are passed to the decoder or sent to the screen by using <a class="el" href="classOpenGLFrameFifo.html" title="A FrameFifo managed and used by OpenGLThread. ">OpenGLFrameFifo</a> (see <a class="el" href="process_chart.html">Library architecture</a>).</p>
<p>Sending frames happens roughly as follows:</p>
<ul>
<li><a class="el" href="classLiveFifo.html" title="This is a special FrameFifo class for feeding frames into live555, i.e. ">LiveFifo</a> has a reference to the associated <a class="el" href="classLiveThread.html" title="Live555, running in a separate thread. ">LiveThread</a></li>
<li>Let's remember that calls to <a class="el" href="classLiveFifo.html#af1040c40ceafed60fe2d60a5f24baa9b" title="Take a frame &quot;ftmp&quot; from the stack, copy contents of &quot;f&quot; into &quot;ftmp&quot; and insert &quot;ftmp&quot; into the begin...">LiveFifo::writeCopy</a> are done outside the running <a class="el" href="classLiveThread.html" title="Live555, running in a separate thread. ">LiveThread</a> that's sending frames. Typically by <a class="el" href="classFifoFrameFilter.html" title="Passes frames to a FrameFifo. ">FifoFrameFilter</a>.</li>
<li><a class="el" href="classLiveFifo.html#af1040c40ceafed60fe2d60a5f24baa9b" title="Take a frame &quot;ftmp&quot; from the stack, copy contents of &quot;f&quot; into &quot;ftmp&quot; and insert &quot;ftmp&quot; into the begin...">LiveFifo::writeCopy</a> calls <a class="el" href="classLiveThread.html#a47a38d1355ad221b09c426eb5f4666a8" title="See Live streaming. ">LiveThread::triggerGotFrames</a> which triggers an event using the scheduler and the triggerEvent method (this is the only allowed way to launch events outside the live555 event loop)</li>
<li>The triggered event corresponds to <a class="el" href="classLiveThread.html#a3da513578a82adf0d121e6b134fd6f52" title="Triggered when an empty fifo gets a frame. Schedules readFrameFifoTask. See Live streaming. ">LiveThread::gotFramesEvent</a></li>
<li><a class="el" href="classLiveThread.html#a3da513578a82adf0d121e6b134fd6f52" title="Triggered when an empty fifo gets a frame. Schedules readFrameFifoTask. See Live streaming. ">LiveThread::gotFramesEvent</a> inserts a new (immediate) task to the live555 event loop, namely <a class="el" href="classLiveThread.html#a2e68caeedbc0166262a833003059e147" title="This task registers itself if there are frames in the fifo. ">LiveThread::readFrameFifoTask</a></li>
<li><a class="el" href="classLiveThread.html#a2e68caeedbc0166262a833003059e147" title="This task registers itself if there are frames in the fifo. ">LiveThread::readFrameFifoTask</a> (i) calls <a class="el" href="classLiveThread.html#a88b224ee73f6c63b4c073eb23351e806" title="Handle incoming frames. See Live streaming. ">LiveThread::handleFrame</a> and (ii) re-schedules itself if there are more than one frame in the fifo</li>
<li><a class="el" href="classLiveThread.html#a88b224ee73f6c63b4c073eb23351e806" title="Handle incoming frames. See Live streaming. ">LiveThread::handleFrame</a> checks the slot of the outgoing frame, takes the corresponding <a class="el" href="classOutbound.html" title="A base class that unifies all kinds of outgoing streams (i.e. ">Outbound</a> instance and calls <a class="el" href="classOutbound.html#aa79c5b31b4c4d7fa0d5a8b409232bb68" title="Setup session and subsessions, writes payload. ">Outbound::handleFrame</a></li>
</ul>
<h2>SDP Streams </h2>
<p>Streams sent directly to UDP ports, as defined in an SDP file ("SDP" streams)</p>
<ul>
<li><a class="el" href="classSDPOutbound.html" title="Sending a stream without rtsp negotiation (i.e. ">SDPOutbound</a> has a set of <a class="el" href="classStream.html" title="An outbound Stream. ">Stream</a> instances in Outbound::streams. There is a <a class="el" href="classStream.html" title="An outbound Stream. ">Stream</a> instance per media substream.</li>
<li><a class="el" href="classStream.html" title="An outbound Stream. ">Stream</a> instances encapsulate the usual live555 stuff per substream: RTPSink, RTCPInstance, Groupsock, FramedSource, etc.</li>
<li>Each <a class="el" href="classStream.html" title="An outbound Stream. ">Stream</a> has also a reference to <a class="el" href="classLiveFifo.html" title="This is a special FrameFifo class for feeding frames into live555, i.e. ">LiveFifo</a> and <a class="el" href="classStream.html#a79b7e99786a5e067c83e3bba9c970300" title="Reserved in the child classes (depends on the payload type) ">Stream::buffer_source</a> which is a <a class="el" href="classBufferSource.html" title="Implements a FramedSource for sending frames. ">BufferSource</a> instance.</li>
<li><a class="el" href="classBufferSource.html" title="Implements a FramedSource for sending frames. ">BufferSource</a> is a subclass of live555 FramedSource that is used for sending frames.</li>
<li><a class="el" href="classBufferSource.html" title="Implements a FramedSource for sending frames. ">BufferSource</a> has it's own internal fifo <a class="el" href="classBufferSource.html#a33a2baa22bce4df04bd78d7a0a7e5cce" title="Internal fifo BasicFrame, i.e. payload frames. ">BufferSource::internal_fifo</a>. This fifo is used by <a class="el" href="classBufferSource.html#a796bc84e5233c21c379a57f2a3b65e54" title="All the fun happens here. ">BufferSource::doGetNextFrame</a>, as it should in live555, i.e. if there are no frames left in the fifo, then <a class="el" href="classBufferSource.html#a796bc84e5233c21c379a57f2a3b65e54" title="All the fun happens here. ">BufferSource::doGetNextFrame</a> exits immediately, otherwise it calls FramedSource::afterGetting and if necessary, re-schedules itself</li>
<li>To summarize, the call chain looks like this: <a class="el" href="classLiveThread.html#a88b224ee73f6c63b4c073eb23351e806" title="Handle incoming frames. See Live streaming. ">LiveThread::handleFrame</a> =&gt; <a class="el" href="classOutbound.html#aa79c5b31b4c4d7fa0d5a8b409232bb68" title="Setup session and subsessions, writes payload. ">Outbound::handleFrame</a> =&gt; Stream::handleFrame (transfers the frame from <a class="el" href="classLiveFifo.html" title="This is a special FrameFifo class for feeding frames into live555, i.e. ">LiveFifo</a> to <a class="el" href="classBufferSource.html#a33a2baa22bce4df04bd78d7a0a7e5cce" title="Internal fifo BasicFrame, i.e. payload frames. ">BufferSource::internal_fifo</a>) =&gt; <a class="el" href="classBufferSource.html#a04cb4018658d080aec540054e5936761" title="Copies a Frame from BufferSource::fifo into BufferSource::internal_fifo. Sets BufferSource::active. Checks that FrameClass is FrameClass::basic. ">BufferSource::handleFrame</a> =&gt; FramedSource::afterGetting</li>
<li>The Live555 filterchain looks like this: <pre class="fragment">buffer_source  =new BufferSource(env, fifo, 0, 0, 4); // nalstamp offset: 4
terminal       =H264VideoStreamDiscreteFramer::createNew(env, buffer_source);

sink           = H264VideoRTPSink::createNew(env,rtpGroupsock, 96);

sink-&gt;startPlaying(*(terminal), this-&gt;afterPlaying, this);
</pre></li>
<li><p class="startli">Frames flow like this: <a class="el" href="classBufferSource.html" title="Implements a FramedSource for sending frames. ">BufferSource</a> =&gt; H264VideoStreamDiscreteFramer =&gt; H264VideoRTPSink</p>
<p class="startli">This diagram, where "{}" means enclosing object will help you to understand this: </p><pre class="fragment">BufferSource (.., fifo) {
   - Live555 FramedSource class with method "doGetNextFrame"
   - Recycles frames back to fifo (in doGetNextFrame)
}

Stream {
   RTPSink,
   RTCPInstance,
   Groupsock,
   BufferSource *buffer_source,
   FrameFifo &amp;fifo,
   
   methods:
       startPlaying
           - issues startPlaying on the live555 
             event loop (for the internal live555 
             filterchain defined in the Stream subclasses)
       afterPlaying
           - a live555 callback
}

H264 : public Stream {
   - Instantiates buffer_source = new BufferSource (.., fifo)
   - Creates the live555 internal filterchain
}
</pre></li>
</ul>
<h2>RTSP Server </h2>
<p>Some misc. observations / code walkthrough:</p>
<ul>
<li>Inheritance: <a class="el" href="classH264ServerMediaSubsession.html">H264ServerMediaSubsession</a> =&gt; <a class="el" href="classValkkaServerMediaSubsession.html">ValkkaServerMediaSubsession</a> =&gt; OnDemandServerMediaSubsession</li>
<li><a class="el" href="classH264ServerMediaSubsession.html">H264ServerMediaSubsession</a> is placed into LiveThread::server (which is RTSPServer instance)</li>
<li>H264ServerMediaSubsession::createNewStreamSource is called from OnDemandServerMediaSubsession::sdpLines when a DESCRIBE request is done on the RTSPServer</li>
<li>OnDemandServerMediaSubsession::closeStreamSource calls Medium::close on inputsource it obtained from H264ServerMediaSubsession::createNewStreamSource, when TEARDOWN is issued on the RTSPServer.</li>
<li>.. this basically closes our <a class="el" href="classBufferSource.html" title="Implements a FramedSource for sending frames. ">BufferSource</a> instance (that's using a fifo), so we need to check if <a class="el" href="classBufferSource.html" title="Implements a FramedSource for sending frames. ">BufferSource</a> has been destructed</li>
<li>.. this is done using a reference variable that's given to <a class="el" href="classBufferSource.html" title="Implements a FramedSource for sending frames. ">BufferSource</a> (<a class="el" href="classValkkaServerMediaSubsession.html#a40c93db49c8364ea71b22288c3a5eab4" title="A canary variable that tells us if live555 event loop has closed the buffer_source. ">ValkkaServerMediaSubsession::source_alive</a>). That variable is checked before calling <a class="el" href="classBufferSource.html#a04cb4018658d080aec540054e5936761" title="Copies a Frame from BufferSource::fifo into BufferSource::internal_fifo. Sets BufferSource::active. Checks that FrameClass is FrameClass::basic. ">BufferSource::handleFrame</a>.</li>
<li>There is a tricky inner event loop that generates sps/pps info into the sdp string at H264ServerMediaSubsession::getAuxSDPLine .. (as this has been hacked from H264VideoFileServerMediaSubsession). That can get stuck sometimes (!)</li>
<li>Media sessions can be removed from the server with RTSPServer::removeServerMediaSession(media_session)</li>
</ul>
<p>To get this into one's head, let's take a look at this diagram. "{}" means enclosing object: </p><pre class="fragment">RTSPServer {

   H264ServerMediaSubsession {
       - member "fifo" is a reference to FrameFifo
   
       - method : createNewStreamSource
           - creates buffer_source = BufferSource (.., fifo)
           - creates H264VideoStreamDiscreteFramer(buffer_source)
           =&gt; returns to RTPServer: H264VideoStreamDiscreteFramer(buffer_source)
           
       - inherited method sdpLines
       - inherited method closeStreamSource
   }
}
</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
